<!doctypehtml><html class=dark lang=en><meta charset=UTF-8><meta content=width=device-width,initial-scale=1.0 name=viewport><title>Robotic Arm Demo</title><style>body{color:#f0f0f0;background-color:#121212;flex-direction:column;justify-content:center;align-items:center;min-height:100vh;margin:0;font-family:sans-serif;display:flex}canvas{background-color:#f0f0f0;border:1px solid #333}*,:before,:after{box-sizing:border-box;border:0 solid #e5e7eb}:before,:after{--tw-content:""}html,:host{-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;line-height:1.5}body{line-height:inherit;margin:0}hr{color:inherit;border-top-width:1px;height:0}abbr:where([title]){text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-feature-settings:normal;font-variation-settings:normal;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-feature-settings:inherit;font-variation-settings:inherit;font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:#0000;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{margin:0;padding:0;list-style:none}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}[hidden]{display:none}*,:before,:after,::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:#3b82f680;--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }.mb-1{margin-bottom:.25rem}.mb-2{margin-bottom:.5rem}.mb-4{margin-bottom:1rem}.mt-4{margin-top:1rem}.block{display:block}.flex{display:flex}.hidden{display:none}.h-6{height:1.5rem}.w-16{width:4rem}.w-20{width:5rem}.w-24{width:6rem}.w-32{width:8rem}.w-6{width:1.5rem}.w-\[95\%\]{width:95%}.w-full{width:100%}.max-w-\[95\%\]{max-width:95%}.rotate-180{--tw-rotate:180deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y))rotate(var(--tw-rotate))skewX(var(--tw-skew-x))skewY(var(--tw-skew-y))scaleX(var(--tw-scale-x))scaleY(var(--tw-scale-y))}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y))rotate(var(--tw-rotate))skewX(var(--tw-skew-x))skewY(var(--tw-skew-y))scaleX(var(--tw-scale-x))scaleY(var(--tw-scale-y))}.cursor-pointer{cursor:pointer}.flex-wrap{flex-wrap:wrap}.items-center{align-items:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-x-8{-moz-column-gap:2rem;column-gap:2rem}.gap-y-4{row-gap:1rem}.space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-right:calc(.5rem*var(--tw-space-x-reverse));margin-left:calc(.5rem*calc(1 - var(--tw-space-x-reverse)))}.space-x-4>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-right:calc(1rem*var(--tw-space-x-reverse));margin-left:calc(1rem*calc(1 - var(--tw-space-x-reverse)))}.rounded{border-radius:.25rem}.rounded-lg{border-radius:.5rem}.border{border-width:1px}.border-b{border-bottom-width:1px}.border-dark-border{--tw-border-opacity:1;border-color:rgb(51 51 51/var(--tw-border-opacity))}.bg-blue-500{--tw-bg-opacity:1;background-color:rgb(59 130 246/var(--tw-bg-opacity))}.bg-dark-bg{--tw-bg-opacity:1;background-color:rgb(18 18 18/var(--tw-bg-opacity))}.bg-dark-control-bg{--tw-bg-opacity:1;background-color:rgb(30 30 30/var(--tw-bg-opacity))}.bg-red-500{--tw-bg-opacity:1;background-color:rgb(239 68 68/var(--tw-bg-opacity))}.p-1{padding:.25rem}.p-4{padding:1rem}.px-4{padding-left:1rem;padding-right:1rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.pb-4{padding-bottom:1rem}.text-center{text-align:center}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.font-bold{font-weight:700}.font-medium{font-weight:500}.font-semibold{font-weight:600}.text-dark-control-fg{--tw-text-opacity:1;color:rgb(221 221 221/var(--tw-text-opacity))}.text-dark-fg{--tw-text-opacity:1;color:rgb(240 240 240/var(--tw-text-opacity))}.text-white{--tw-text-opacity:1;color:rgb(255 255 255/var(--tw-text-opacity))}.shadow-md{--tw-shadow:0 4px 6px -1px #0000001a,0 2px 4px -2px #0000001a;--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color),0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.transition-transform{transition-property:transform;transition-duration:.15s;transition-timing-function:cubic-bezier(.4,0,.2,1)}.duration-300{transition-duration:.3s}.hover\:bg-blue-700:hover{--tw-bg-opacity:1;background-color:rgb(29 78 216/var(--tw-bg-opacity))}.hover\:bg-red-700:hover{--tw-bg-opacity:1;background-color:rgb(185 28 28/var(--tw-bg-opacity))}</style></head><body class="bg-dark-bg text-dark-fg"><div style=margin-top:5vh></div><div id=canvasDiv></div><div class="bg-dark-control-bg p-4 border border-dark-border rounded-lg shadow-md mt-4 w-[95%] max-w-[95%]"id=controls-container><div class="flex justify-between items-center mb-4 cursor-pointer"onclick=toggleControls()><h2 class="text-xl font-semibold text-dark-control-fg">Expand controls</h2><svg class="w-6 h-6 text-dark-control-fg transform rotate-180 transition-transform duration-300"viewbox="0 0 24 24"fill=none id=collapse-icon stroke=currentColor><path d="M19 9l-7 7-7-7"stroke-linecap=round stroke-linejoin=round stroke-width=2 /></svg></div><div class="flex flex-wrap justify-center gap-x-8 gap-y-4 pb-4 border-b border-dark-border hidden"id=controls><div class="w-full border-b border-dark-border mb-4 pb-4"><h3 class="text-lg font-semibold text-dark-control-fg mb-2 text-center">PID Parameters</h3><div class=pid-control><label class="block text-sm font-medium text-dark-control-fg mb-1"for=kpSlider>Kp</label><div class="flex items-center space-x-2"><input class=w-32 id=kpSlider max=1 min=0 step=0.01 type=range value=0.1><input class="w-20 p-1 text-sm rounded text-dark-fg bg-dark-bg border border-dark-border"id=kpInput max=1 min=0 step=0.01 type=number value=0.1></div></div><div class=pid-control><label class="block text-sm font-medium text-dark-control-fg mb-1"for=kiSlider>Ki</label><div class="flex items-center space-x-2"><input class=w-32 id=kiSlider max=0.01 min=0 step=0.0001 type=range value=0.0><input class="w-20 p-1 text-sm rounded text-dark-fg bg-dark-bg border border-dark-border"id=kiInput max=0.01 min=0 step=0.0001 type=number value=0.0></div></div><div class=pid-control><label class="block text-sm font-medium text-dark-control-fg mb-1"for=kdSlider>Kd</label><div class="flex items-center space-x-2"><input class=w-32 id=kdSlider max=0.5 min=0 step=0.001 type=range value=0.22><input class="w-20 p-1 text-sm rounded text-dark-fg bg-dark-bg border border-dark-border"id=kdInput max=0.5 min=0 step=0.001 type=number value=0.22></div></div></div><div class=joint-limits><label class="block text-sm font-medium text-dark-control-fg mb-2 text-center">Joint 1 Limits (Â°)</label><div class="limit-pair flex items-center space-x-2 mb-1"><label class="block text-sm font-medium text-dark-control-fg"for=joint1MinSlider>Min</label><input class=w-24 id=joint1MinSlider max=180 min=-180 step=5 type=range value=-150><input class="w-16 p-1 text-sm rounded text-dark-fg bg-dark-bg border border-dark-border"id=joint1MinInput max=180 min=-180 step=1 type=number value=-150></div><div class="limit-pair flex items-center space-x-2"><label class="block text-sm font-medium text-dark-control-fg"for=joint1MaxSlider>Max</label><input class=w-24 id=joint1MaxSlider max=180 min=-180 step=5 type=range value=-20><input class="w-16 p-1 text-sm rounded text-dark-fg bg-dark-bg border border-dark-border"id=joint1MaxInput max=180 min=-180 step=1 type=number value=-20></div></div><div class=joint-limits><label class="block text-sm font-medium text-dark-control-fg mb-2 text-center">Joint 2 Limits (Â°)</label><div class="limit-pair flex items-center space-x-2 mb-1"><label class="block text-sm font-medium text-dark-control-fg"for=joint2MinSlider>Min</label><input class=w-24 id=joint2MinSlider max=180 min=-180 step=5 type=range value=0><input class="w-16 p-1 text-sm rounded text-dark-fg bg-dark-bg border border-dark-border"id=joint2MinInput max=180 min=-180 step=1 type=number value=0></div><div class="limit-pair flex items-center space-x-2"><label class="block text-sm font-medium text-dark-control-fg"for=joint2MaxSlider>Max</label><input class=w-24 id=joint2MaxSlider max=180 min=-180 step=5 type=range value=155><input class="w-16 p-1 text-sm rounded text-dark-fg bg-dark-bg border border-dark-border"id=joint2MaxInput max=180 min=-180 step=1 type=number value=155></div></div><div class=joint-limits><label class="block text-sm font-medium text-dark-control-fg mb-2 text-center">Joint 3 Limits (Â°)</label><div class="limit-pair flex items-center space-x-2 mb-1"><label class="block text-sm font-medium text-dark-control-fg"for=joint3MinSlider>Min</label><input class=w-24 id=joint3MinSlider max=180 min=-180 step=5 type=range value=0><input class="w-16 p-1 text-sm rounded text-dark-fg bg-dark-bg border border-dark-border"id=joint3MinInput max=180 min=-180 step=1 type=number value=0></div><div class="limit-pair flex items-center space-x-2"><label class="block text-sm font-medium text-dark-control-fg"for=joint3MaxSlider>Max</label><input class=w-24 id=joint3MaxSlider max=180 min=-180 step=5 type=range value=155><input class="w-16 p-1 text-sm rounded text-dark-fg bg-dark-bg border border-dark-border"id=joint3MaxInput max=180 min=-180 step=1 type=number value=155></div></div></div><div class="flex justify-center space-x-4 mt-4"id=action-buttons><button class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded"id=resetButton>Reset Scene</button><button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"id=createBallButton>Create Ball</button><button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"id=createBoxButton>Create Cube</button></div></div><script>const controlsDiv = document.getElementById('controls');
        const collapseIcon = document.getElementById('collapse-icon');
        let controlsVisible = false;

        function toggleControls() {
            controlsVisible = !controlsVisible;
            if (controlsVisible) {
                controlsDiv.classList.remove('hidden');
                collapseIcon.classList.remove('rotate-180');
            } else {
                controlsDiv.classList.add('hidden');
                collapseIcon.classList.add('rotate-180');
            }
        }

        toggleControls();</script><script src=https://cdn.jsdelivr.net/npm/p5@1.11.3/lib/p5.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.20.0/matter.min.js></script><script>let engine, world;
let ground, platform, cube, greenBall;
let grabbedCube = null;
let grabbedBall = null;
let gripperClosed = false;
let justClosedGripper = false;

const ARM_SEGMENTS = [180, 130, 100];
const SEGMENT_COLORS = ['#FF0000', '#FFA500', '#FFD700'];
const ANCHOR = { x: 0, y: 0 };
const GRAB_THRESHOLD = 30;
const LAST_SEGMENT_VISUAL_OFFSET = 26;
const GRIPPER_OFFSET = 5;

const MAX_JOINT_ACCELERATION = 0.03;
const MAX_JOINT_VELOCITY = 0.1;
const DAMPING_FACTOR = 0.5;
const IK_ITERATIONS = 30;

// PID Gains
let KP, KI, KD;

let jointAngles = [0, 0, 0];
let jointVelocities = [0, 0, 0];
let targetAngles = [0, 0, 0];

let integralError = [0, 0, 0];
let previousError = [0, 0, 0];

// UI stuff
let kpSlider, kiSlider, kdSlider;
let kpInput, kiInput, kdInput;
let resetButton;
let createBallButton, createBoxButton;

// Joint limit UI elements and variables
let joint1MinSlider, joint1MaxSlider, joint2MinSlider, joint2MaxSlider, joint3MinSlider, joint3MaxSlider;
let joint1MinInput, joint1MaxInput, joint2MinInput, joint2MaxInput, joint3MinInput, joint3MaxInput;
let jointAngleLimits = [[-150, -20], [0, 155], [0, 155]];

// Scene objects arrays
let armBase;
let balls = [];
let cubes = [];


class Block {
    /** Represents a rectangular block in the physics world. */
    constructor(world, options, matterOptions) {
        this.body = Matter.Bodies.rectangle(options.x, options.y, options.w, options.h, matterOptions);
        Matter.World.add(world, this.body);
        this.w = options.w;
        this.h = options.h;
        this.color = options.color;
    }

    /** Draws the block on the canvas. */
    draw() {
        const pos = this.body.position;
        const angle = this.body.angle;

        push();
        translate(pos.x, pos.y);
        rotate(angle);
        rectMode(CENTER);
        fill(this.color);
        rect(0, 0, this.w, this.h);
        pop();
    }
}

class Ball {
    /** Represents a circular ball in the physics world. */
    constructor(world, options, matterOptions) {
        this.body = Matter.Bodies.circle(options.x, options.y, options.r, matterOptions);
        Matter.World.add(world, this.body);
        this.r = options.r;
        this.color = options.color;
    }

    /** Draws the ball on the canvas. */
    draw() {
        const pos = this.body.position;
        const angle = this.body.angle;

        push();
        translate(pos.x, pos.y);
        rotate(angle);
        ellipseMode(RADIUS);
        fill(this.color);
        circle(0, 0, this.r);
        pop();
    }
}


/** Setup function to initialize the p5.js sketch and Matter.js engine. */
function setup() {
    const canvas = createCanvas(800, 500);
    canvas.parent('canvasDiv');

    ANCHOR.x = width / 4;
    ANCHOR.y = height - 50;

    engine = Matter.Engine.create();
    world = engine.world;
    engine.gravity.scale = 0.001;

    ground = new Block(world, { x: width/2, y: height-10, w: width, h: 20, color: '#666' }, { isStatic: true });
    platform = new Block(world, { x: width/2 + 200, y: height-150, w: 200, h: 20, color: '#444' }, { isStatic: true });
    cube = new Block(world, { x: width/2 - 100, y: 100, w: 30, h: 30, color: '#2196F3' }, { isStatic: false, restitution: 0.7 });

    cubes.push(cube);

    armBase = new Block(world, {
        x: ANCHOR.x, y: ANCHOR.y + 50, w: 80, h: 100, color: '#888'
    }, { isStatic: true });

    greenBall = new Ball(world, {
        x: width/2 - 150, y: 100, r: 25, color: 'green'
    }, { isStatic: false, restitution: 0.6 });

    balls.push(greenBall);


    Matter.Runner.run(engine);

    // Get UI elements
    kpSlider = document.getElementById('kpSlider');
    kiSlider = document.getElementById('kiSlider');
    kdSlider = document.getElementById('kdSlider');
    kpInput = document.getElementById('kpInput');
    kiInput = document.getElementById('kiInput');
    kdInput = document.getElementById('kdInput');
    resetButton = document.getElementById('resetButton');
    createBallButton = document.getElementById('createBallButton');
    createBoxButton = document.getElementById('createBoxButton');

    // Joint limit UI elements
    joint1MinSlider = document.getElementById('joint1MinSlider');
    joint1MaxSlider = document.getElementById('joint1MaxSlider');
    joint2MinSlider = document.getElementById('joint2MinSlider');
    joint2MaxSlider = document.getElementById('joint2MaxSlider');
    joint3MinSlider = document.getElementById('joint3MinSlider');
    joint3MaxSlider = document.getElementById('joint3MaxSlider');
    joint1MinInput = document.getElementById('joint1MinInput');
    joint1MaxInput = document.getElementById('joint1MaxInput');
    joint2MinInput = document.getElementById('joint2MinInput');
    joint2MaxInput = document.getElementById('joint2MaxInput');
    joint3MinInput = document.getElementById('joint3MinInput');
    joint3MaxInput = document.getElementById('joint3MaxInput');


    // Initialize PID gains from input values
    KP = parseFloat(kpInput.value);
    KI = parseFloat(kiInput.value);
    KD = parseFloat(kdInput.value);

    // Initialize Joint Limits from input values (in degrees) and convert to radians
    jointAngleLimits[0][0] = radians(parseFloat(joint1MinInput.value));
    jointAngleLimits[0][1] = radians(parseFloat(joint1MaxInput.value));
    jointAngleLimits[1][0] = radians(parseFloat(joint2MinInput.value));
    jointAngleLimits[1][1] = radians(parseFloat(joint2MaxInput.value));
    jointAngleLimits[2][0] = radians(parseFloat(joint3MinInput.value));
    jointAngleLimits[2][1] = radians(parseFloat(joint3MaxInput.value));


    // Slider and Input synchronization and update gains on change (PID)
    kpSlider.oninput = () => { kpInput.value = kpSlider.value; KP = parseFloat(kpSlider.value); };
    kpInput.onchange = () => { kpSlider.value = kpInput.value; KP = parseFloat(kpInput.value); };
    kiSlider.oninput = () => { kiInput.value = kiSlider.value; KI = parseFloat(kiSlider.value); };
    kiInput.onchange = () => { kiSlider.value = kiInput.value; KI = parseFloat(kiInput.value); };
    kdSlider.oninput = () => { kdInput.value = kdSlider.value; KD = parseFloat(kdSlider.value); };
    kdInput.onchange = () => { kdSlider.value = kdInput.value; KD = parseFloat(kdInput.value); };

    // Slider and Input synchronization and update Joint Limits on change (Angle Limits)
    setupLimitControl(joint1MinSlider, joint1MinInput, 0, 0);
    setupLimitControl(joint1MaxSlider, joint1MaxInput, 0, 1);
    setupLimitControl(joint2MinSlider, joint2MinInput, 1, 0);
    setupLimitControl(joint2MaxSlider, joint2MaxInput, 1, 1);
    setupLimitControl(joint3MinSlider, joint3MinInput, 2, 0);
    setupLimitControl(joint3MaxSlider, joint3MaxInput, 2, 1);


    resetButton.onclick = resetScene;
    createBallButton.onclick = createNewBall;
    createBoxButton.onclick = createNewBox;

    // Keyboard shortcuts
    document.addEventListener('keydown', function(event) {
        if (event.key === 'r' || event.key === 'R') {
            resetButton.click();
        } else if (event.key === 'b' || event.key === 'B') {
            createBallButton.click();
        } else if (event.key === 'c' || event.key === 'C') {
            createBoxButton.click();
        }
    });
}

/** Helper function to setup slider-input sync for joint limits. */
function setupLimitControl(slider, input, jointIndex, limitIndex) {
    slider.oninput = () => {
        input.value = slider.value;
        jointAngleLimits[jointIndex][limitIndex] = radians(parseFloat(slider.value));
    };
    input.onchange = () => {
        slider.value = input.value;
        jointAngleLimits[jointIndex][limitIndex] = radians(parseFloat(input.value));
    };
}


/** Draw function, executed every frame to update the scene. */
function draw() {
    // https://p5js.org/reference/p5/background/
    background(180); // A light gray

    Matter.Engine.update(engine, 16);

    ground.draw();
    platform.draw();

    for (let cube of cubes) {
        cube.draw();
    }
    for (let ball of balls) {
        ball.draw();
    }

    armBase.draw();

    const mouseTarget = createVector(mouseX, mouseY);
    targetAngles = calculateIK(mouseTarget);

    // PID Control for each joint
    for (let i = 0; i < jointAngles.length; i++) {
        let angleError = targetAngles[i] - jointAngles[i];

        let proportionalTerm = KP * angleError;
        integralError[i] += angleError;
        let integralTerm = KI * integralError[i];
        let derivativeTerm = KD * (angleError - previousError[i]);
        previousError[i] = angleError;

        let desiredVelocity = proportionalTerm + integralTerm + derivativeTerm;
        let velocityChange = desiredVelocity - jointVelocities[i];

        if (abs(velocityChange) > MAX_JOINT_ACCELERATION) {
            velocityChange = Math.sign(velocityChange) * MAX_JOINT_ACCELERATION;
        }

        jointVelocities[i] += velocityChange;
        jointAngles[i] += jointVelocities[i];

        jointVelocities[i] = Math.max(-MAX_JOINT_VELOCITY, Math.min(jointVelocities[i], MAX_JOINT_VELOCITY));
    }


    drawArm(jointAngles);

    const gripperPos = getGripperPosition(jointAngles);

    let objectGrabbedThisFrame = false;

    if (justClosedGripper && !grabbedBall) {
        for (let cube of cubes) {
            if (!grabbedCube) {
                const cubePos = cube.body.position;
                let dCube = dist(gripperPos.x, gripperPos.y, cubePos.x, cubePos.y);
                if (dCube < GRAB_THRESHOLD) {
                    grabbedCube = cube;
                    Matter.Body.setStatic(cube.body, true);
                    objectGrabbedThisFrame = true;
                    break;
                }
            }
        }
    }

    if (justClosedGripper && !grabbedCube && !objectGrabbedThisFrame) {
        for (let ball of balls) {
            if (!grabbedBall) {
                const ballPos = ball.body.position;
                let dBall = dist(gripperPos.x, gripperPos.y, ballPos.x, ballPos.y);
                if (dBall < GRAB_THRESHOLD) {
                    grabbedBall = ball;
                    Matter.Body.setStatic(ball.body, true);
                    objectGrabbedThisFrame = true;
                    break;
                }
            }
        }
    }


    if (grabbedCube) {
        Matter.Body.setPosition(grabbedCube.body, gripperPos);
    }
    if (grabbedBall) {
        Matter.Body.setPosition(grabbedBall.body, gripperPos);
    }


    justClosedGripper = false;
}


/** Handles mouse pressed events for gripper control and object interaction. */
function mousePressed() {
    gripperClosed = !gripperClosed;
    if (gripperClosed) {
        justClosedGripper = true;
    }

    const gripperPos = getGripperPosition(calculateIK(createVector(mouseX, mouseY)));
    cubes.forEach((cube, index) => {
        const cubePos = cube.body.position;
        const dCube = dist(gripperPos.x, gripperPos.y, cubePos.x, cubePos.y);
        console.log(`Cube ${index+1}:`, cubePos);
        console.log(`Distance to Cube ${index+1}:`, dCube.toFixed(1));
    });
    balls.forEach((ball, index) => {
        const ballPos = ball.body.position;
        const dBall = dist(gripperPos.x, gripperPos.y, ballPos.x, ballPos.y);
        console.log(`Ball ${index+1}:`, ballPos);
        console.log(`Distance to Ball ${index+1}:`, dBall.toFixed(1));
    });


    if (!gripperClosed) {
        if (grabbedCube) {
            Matter.Body.setStatic(grabbedCube.body, false);
            grabbedCube = null;
        }
        if (grabbedBall) {
            Matter.Body.setStatic(grabbedBall.body, false);
            grabbedBall = null;
        }
    }
}

/** Calculates Inverse Kinematics to determine joint angles for a target position. */
function calculateIK(target) {
    let angles = jointAngles.slice();

    for (let i = 0; i < IK_ITERATIONS; i++) {
        let endPos = getGripperPosition(angles);

        for (let j = ARM_SEGMENTS.length - 1; j >= 0; j--) {
            const jointPos = getJointPosition(angles, j);
            const toEnd = p5.Vector.sub(endPos, jointPos);
            const toTarget = p5.Vector.sub(target, jointPos);
            let angleDiff = toTarget.heading() - toEnd.heading();
            let angleIncrement = angleDiff * DAMPING_FACTOR;
            angles[j] += angleIncrement;

            // Apply angle limits here
            angles[j] = Math.max(jointAngleLimits[j][0], Math.min(angles[j], jointAngleLimits[j][1]));


            endPos = getGripperPosition(angles);
        }
    }
    return angles;
}

/** Gets the position of a specific joint given the joint angles. */
function getJointPosition(angles, jointIndex) {
    return ARM_SEGMENTS.slice(0, jointIndex).reduce((pos, len, idx) => {
        const angle = angles.slice(0, idx+1).reduce((sum, a) => sum + a, 0);
        return createVector(
            pos.x + len * cos(angle),
            pos.y + len * sin(angle)
        );
    }, createVector(ANCHOR.x, ANCHOR.y));
}


/** Draws the robotic arm on the canvas based on given joint angles. */
function drawArm(angles) {
    let currentPos = createVector(ANCHOR.x, ANCHOR.y);
    let angleSum = 0;

    ARM_SEGMENTS.forEach((len, i) => {
        angleSum += angles[i];

        if (i == 2) {
            len -= LAST_SEGMENT_VISUAL_OFFSET;
        }

        const nextPos = createVector(
            currentPos.x + len * cos(angleSum),
            currentPos.y + len * sin(angleSum)
        );

        stroke(SEGMENT_COLORS[i]);
        strokeWeight(13);
        line(currentPos.x, currentPos.y, nextPos.x, nextPos.y);
        currentPos = nextPos;
    });

    currentPos = createVector(
        currentPos.x + GRIPPER_OFFSET * cos(angleSum),
        currentPos.y + GRIPPER_OFFSET * sin(angleSum)
    );

    // Draw gripper
    stroke(0);
    strokeWeight(6);
    const gripSize = 30;
    const gripSegmentLength = gripSize / 2;
    const inwardAngle = -40 * PI / 180;
    const gripOpenAngle = gripperClosed ? PI/4 : 0;

    const gripAngleBase_R = angleSum - gripOpenAngle + PI/2;
    const gripAngleBase_L = angleSum + gripOpenAngle - PI/2;

    const jointPos_R = createVector(
        currentPos.x + gripSegmentLength * cos(gripAngleBase_R),
        currentPos.y + gripSegmentLength * sin(gripAngleBase_R)
    );
    const endAngle_R = gripAngleBase_R + inwardAngle;
    const endPos_R = createVector(
        jointPos_R.x + gripSegmentLength * cos(endAngle_R),
        jointPos_R.y + gripSegmentLength * sin(endAngle_R)
    );

    line(currentPos.x, currentPos.y, jointPos_R.x, jointPos_R.y);
    line(jointPos_R.x, jointPos_R.y, endPos_R.x, endPos_R.y);


    const jointPos_L = createVector(
        currentPos.x + gripSegmentLength * cos(gripAngleBase_L),
        currentPos.y + gripSegmentLength * sin(gripAngleBase_L)
    );
    const endAngle_L = gripAngleBase_L - inwardAngle;
    const endPos_L = createVector(
        jointPos_L.x + gripSegmentLength * cos(endAngle_L),
        jointPos_L.y + gripSegmentLength * sin(endAngle_L)
    );

    line(currentPos.x, currentPos.y, jointPos_L.x, jointPos_L.y);
    line(jointPos_L.x, jointPos_L.y, endPos_L.x, endPos_L.y);
}

/** Gets the position of the gripper (end effector) based on joint angles. */
function getGripperPosition(angles) {
    return ARM_SEGMENTS.reduce((pos, len, i) => {
        const angle = angles.slice(0, i+1).reduce((sum, a) => sum + a, 0);
        return createVector(
            pos.x + len * cos(angle),
            pos.y + len * sin(angle)
        );
    }, createVector(ANCHOR.x, ANCHOR.y));
}

/** Resets the scene to its initial state, including objects and arm position. */
function resetScene() {
    jointAngles = [0, 0, 0];
    jointVelocities = [0, 0, 0];
    integralError = [0, 0, 0];
    previousError = [0, 0, 0];
    cubes.forEach(cube => Matter.World.remove(world, cube.body));
    balls.forEach(ball => Matter.World.remove(world, ball.body));
    cubes = [];
    balls = [];
    grabbedCube = null;
    grabbedBall = null;

    // Create initial cube and ball after reset
    createNewBox();
    createNewBall();
}


/** Creates a new ball object at a random position in the scene. */
function createNewBall() {
    let newBall = new Ball(world, {
        x: random(width/2 - 300, width/2 + 300), y: 50, r: 25, color: 'green'
    }, { restitution: 0.6 });
    balls.push(newBall);
}

/** Creates a new cube object at a random position in the scene. */
function createNewBox() {
    let newCube = new Block(world, {
        x: random(width/2 - 300, width/2 - 50), y: 50, w: 30, h: 30, color: '#2196F3'
    }, { restitution: 0.7 });
    cubes.push(newCube);
}</script></body></html>